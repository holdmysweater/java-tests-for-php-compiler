package com.phpjvm;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Minimal PHP-like runtime value for "PHP -> JVM bytecode" compiler projects.
 * <p>
 * Design goals:
 * - One boxed value type (NULL/BOOL/INT/FLOAT/STRING/ARRAY)
 * - Static operators: add/sub/mul/div/mod/concat/eq/identical/lt/le
 * - PHP-ish coercions (pragmatic, not 100% spec-perfect)
 * - Arrays with int/string keys (multidimensional arrays work naturally)
 * <p>
 * Your generated bytecode should treat all runtime values as BasePhpValue.
 */
public final class BasePhpValue {

    public enum Type {
        NULL,
        BOOL,
        INT,
        FLOAT,
        STRING,
        ARRAY,
        OBJECT
    }

    // ---------- Singletons / factories ----------
    public static final BasePhpValue NULL_VALUE = new BasePhpValue(Type.NULL, null);

    public static BasePhpValue of(boolean b) {
        return new BasePhpValue(Type.BOOL, b);
    }

    public static BasePhpValue of(long i) {
        return new BasePhpValue(Type.INT, i);
    }

    public static BasePhpValue of(double d) {
        return new BasePhpValue(Type.FLOAT, d);
    }

    public static BasePhpValue of(String s) {
        return s == null ? NULL_VALUE : new BasePhpValue(Type.STRING, s);
    }

    public static BasePhpValue array() {
        return new BasePhpValue(Type.ARRAY, new PhpArray());
    }

    public static BasePhpValue object(PhpObject o) {
        if (o == null) return NULL_VALUE;
        return new BasePhpValue(Type.OBJECT, o);
    }

    /**
     * Convenience: wrap Java objects (handy for tests / quick glue code).
     */
    public static BasePhpValue create(Object v) {
        if (v == null) return NULL_VALUE;
        if (v instanceof BasePhpValue pv) return pv;
        if (v instanceof Boolean b) return of(b);
        if (v instanceof Byte || v instanceof Short || v instanceof Integer || v instanceof Long) {
            return of(((Number) v).longValue());
        }
        if (v instanceof Float || v instanceof Double) {
            return of(((Number) v).doubleValue());
        }
        if (v instanceof String s) return of(s);
        if (v instanceof Map<?, ?> m) {
            BasePhpValue arr = array();
            for (Map.Entry<?, ?> e : m.entrySet()) {
                arr.asArray().put(keyFromJava(e.getKey()), create(e.getValue()));
            }
            return arr;
        }
        throw new PhpRuntimeException("Unsupported host type: " + v.getClass().getName());
    }

    private static PhpKey keyFromJava(Object k) {
        if (k == null) return PhpKey.of("");// pragmatic
        if (k instanceof PhpKey pk) return pk;
        if (k instanceof BasePhpValue pv) return PhpKey.fromValue(pv);
        if (k instanceof Byte || k instanceof Short || k instanceof Integer || k instanceof Long) {
            return PhpKey.of(((Number) k).longValue());
        }
        if (k instanceof Float || k instanceof Double) {
            // PHP array keys: float keys are cast to int
            return PhpKey.of((long) ((Number) k).doubleValue());
        }
        if (k instanceof Boolean b) {
            // PHP: false->0 true->1
            return PhpKey.of(b ? 1L : 0L);
        }
        return PhpKey.of(String.valueOf(k));
    }

    // ---------- Core representation ----------
    private final Type type;
    private final Object value; // Boolean, Long, Double, String, PhpArray, or null

    private BasePhpValue(Type type, Object value) {
        this.type = Objects.requireNonNull(type, "type");
        this.value = value;
    }

    public Type getType() {
        return type;
    }

    // ---------- Type checks ----------
    public boolean isNull() {
        return type == Type.NULL;
    }

    public boolean isBool() {
        return type == Type.BOOL;
    }

    public boolean isInt() {
        return type == Type.INT;
    }

    public boolean isFloat() {
        return type == Type.FLOAT;
    }

    public boolean isNumber() {
        return type == Type.INT || type == Type.FLOAT;
    }

    public boolean isString() {
        return type == Type.STRING;
    }

    public boolean isArray() {
        return type == Type.ARRAY;
    }

    public boolean isObject() {
        return type == Type.OBJECT;
    }

    // ---------- Refs ----------

    public static boolean isRef(BasePhpValue v) {
        if (v == null) return false;
        if (v.type != Type.OBJECT) return false;
        Object o = v.value;
        if (!(o instanceof PhpObject po)) return false;
        return po.isReference();
    }

    public static BasePhpValue deref(BasePhpValue v) {
        if (v == null) return NULL_VALUE;
        if (v.type == Type.OBJECT && v.value instanceof PhpObject po && po.isReference()) {
            return po.refGet();
        }
        return v;
    }

    public static BasePhpValue requireRef(BasePhpValue v, String fn, int index, String paramName) {
        if (!isRef(v)) {
            String n = (fn == null || fn.isEmpty()) ? "<function>" : fn;
            String p = (paramName == null || paramName.isEmpty()) ? "" : " ($" + paramName + ")";
            throw new PhpTypeError(n + "(): Argument " + index + p + " must be passed by reference");
        }
        return v;
    }

    public static BasePhpValue assignToRef(BasePhpValue ref, BasePhpValue value) {
        if (!isRef(ref)) {
            throw new PhpRuntimeException("Attempt to assign to non-reference");
        }
        PhpObject po = (PhpObject) ref.value;
        BasePhpValue v = (value == null) ? NULL_VALUE : value;
        po.refSet(v);
        return v;
    }

    // ---------- Accessors ----------
    public boolean asBoolStrict() {
        if (!isBool()) throw cant("bool");
        return (Boolean) value;
    }

    public long asLongStrict() {
        if (!isInt()) throw cant("int");
        return (Long) value;
    }

    public double asDoubleStrict() {
        if (!isFloat()) throw cant("float");
        return (Double) value;
    }

    public String asStringStrict() {
        if (!isString()) throw cant("string");
        return (String) value;
    }

    public PhpArray asArray() {
        if (!isArray()) throw cant("array");
        return (PhpArray) value;
    }

    public PhpObject asObject() {
        if (!isObject()) throw cant("object");
        return (PhpObject) value;
    }

    private IllegalStateException cant(String target) {
        return new IllegalStateException("Can't get " + target + " from type " + type);
    }

    // ---------- PHP-ish conversions ----------

    /**
     * PHP-ish "truthiness" (used for if/while, logical ops).
     */
    public boolean toBool() {
        return switch (type) {
            case NULL -> false;
            case BOOL -> (Boolean) value;
            case INT -> ((Long) value) != 0L;
            case FLOAT -> ((Double) value) != 0.0;
            case STRING -> {
                String s = (String) value;
                yield !(s.isEmpty() || s.equals("0"));
            }
            case ARRAY -> !asArray().isEmpty();
            case OBJECT -> true;
        };
    }

    /**
     * Convert to string for echo/print/concatenation.
     * Note: PHP prints arrays as "Array" with a notice; we return "Array".
     */
    public String toPhpString() {
        return switch (type) {
            case NULL -> "";
            case BOOL -> ((Boolean) value) ? "1" : "";
            case INT -> String.valueOf((Long) value);
            case FLOAT -> {
                double d = (Double) value;
                yield stripTrailingZeros(d);
            }
            case STRING -> (String) value;
            case ARRAY -> "Array";
            case OBJECT -> {
                PhpObject obj = (PhpObject) value;
                // PHP: echo object requires __toString, otherwise TypeError
                BasePhpValue r = PhpRuntime.callMethod(obj, "__toString", new BasePhpValue[0]);
                if (r == null) r = NULL_VALUE;
                if (!r.isString()) {
                    throw new PhpTypeError("__toString() must return a string");
                }
                yield r.asStringStrict();
            }
        };
    }


    private static String stripTrailingZeros(double d) {
        String s = Double.toString(d);
        // turn "2.0" into "2" (nice for tests)
        if (s.endsWith(".0")) return s.substring(0, s.length() - 2);
        return s;
    }

    /**
     * Numeric conversion for arithmetic. Pragmatic PHP-like rules:
     * - NULL -> 0
     * - BOOL -> 0/1
     * - INT/FLOAT -> itself
     * - STRING -> parse leading numeric part (like PHP-ish), else 0
     * - ARRAY -> error for arithmetic (PHP warns and usually yields 0 in old versions; modern PHP throws TypeError in many cases)
     */
    private PhpNumber toNumberForArithmetic() {
        return switch (type) {
            case NULL -> PhpNumber.ofLong(0);
            case BOOL -> PhpNumber.ofLong(((Boolean) value) ? 1 : 0);
            case INT -> PhpNumber.ofLong((Long) value);
            case FLOAT -> PhpNumber.ofDouble((Double) value);
            case STRING -> {
                PhpNumber pn = parsePhpNumber((String) value);
                yield (pn == null) ? PhpNumber.ofLong(0) : pn;
            }
            case ARRAY -> PhpNumber.ofLong(0); // your current behavior
            case OBJECT -> throw new PhpTypeError("Unsupported operand type: object");
        };
    }


    private static PhpNumber numForOp(BasePhpValue v, String op, BasePhpValue other) {
        if (v == null) v = NULL_VALUE;

        return switch (v.type) {
            case NULL -> PhpNumber.ofLong(0);
            case BOOL -> PhpNumber.ofLong(((Boolean) v.value) ? 1 : 0);
            case INT -> PhpNumber.ofLong((Long) v.value);
            case FLOAT -> PhpNumber.ofDouble((Double) v.value);
            case STRING -> {
                PhpNumber pn = parsePhpNumber((String) v.value);
                if (pn == null) throw unsupportedOperandTypes(op, v, other);
                yield pn;
            }
            case ARRAY, OBJECT -> throw unsupportedOperandTypes(op, v, other);
        };
    }

    /**
     * Parse "PHP-ish" numeric: leading whitespace, optional sign, digits, optional dot+digits.
     * Stops at first non-numeric char.
     */
    private static PhpNumber parsePhpNumber(String s) {
        if (s == null) return null;

        int n = s.length();
        int i = 0;

        // leading whitespace
        while (i < n && Character.isWhitespace(s.charAt(i))) i++;
        if (i >= n) return null;

        // sign
        boolean neg = false;
        char c = s.charAt(i);
        if (c == '+' || c == '-') {
            neg = (c == '-');
            i++;
            if (i >= n) return null;
        }

        boolean sawDigit = false;
        long intPart = 0;

        // digits before dot
        while (i < n) {
            char ch = s.charAt(i);
            if (ch >= '0' && ch <= '9') {
                sawDigit = true;
                int digit = ch - '0';
                if (intPart > (Long.MAX_VALUE - digit) / 10) {
                    intPart = Long.MAX_VALUE;
                } else {
                    intPart = intPart * 10 + digit;
                }
                i++;
            } else break;
        }

        boolean isFloat = false;
        double frac = 0.0;
        double base = 1.0;

        // dot + digits
        if (i < n && s.charAt(i) == '.') {
            isFloat = true;
            i++;
            while (i < n) {
                char ch = s.charAt(i);
                if (ch >= '0' && ch <= '9') {
                    sawDigit = true;
                    int digit = ch - '0';
                    base *= 10.0;
                    frac += digit / base;
                    i++;
                } else break;
            }
        }

        // exponent part (e.g., 1e3, 1.2E-4)
        int exp = 0;
        boolean expNeg = false;
        boolean hasExp = false;
        if (i < n && (s.charAt(i) == 'e' || s.charAt(i) == 'E')) {
            int j = i + 1;
            if (j < n && (s.charAt(j) == '+' || s.charAt(j) == '-')) {
                expNeg = (s.charAt(j) == '-');
                j++;
            }
            boolean sawExpDigit = false;
            while (j < n) {
                char ch = s.charAt(j);
                if (ch >= '0' && ch <= '9') {
                    sawExpDigit = true;
                    int digit = ch - '0';
                    if (exp > (Integer.MAX_VALUE - digit) / 10) {
                        exp = Integer.MAX_VALUE;
                    } else {
                        exp = exp * 10 + digit;
                    }
                    j++;
                } else break;
            }
            if (sawExpDigit) {
                hasExp = true;
                i = j;
                isFloat = true; // exponent implies float semantics
            } else {
                // "1e" is not numeric
                return null;
            }
        }

        // trailing whitespace allowed
        while (i < n && Character.isWhitespace(s.charAt(i))) i++;

        // if any junk remains -> treat as NOT numeric (strict)
        if (i != n) return null;

        if (!sawDigit) return null;

        double d = (double) intPart + frac;
        if (neg) d = -d;

        if (hasExp) {
            int signedExp = expNeg ? -exp : exp;
            d = d * Math.pow(10.0, signedExp);
            return PhpNumber.ofDouble(d);
        }

        if (isFloat) return PhpNumber.ofDouble(d);

        long v = neg ? -intPart : intPart;
        return PhpNumber.ofLong(v);
    }

    // ---------- Numeric-string detection (STRICT, for comparisons) ----------
// Returns null if s is NOT a numeric string.
// Accepts leading/trailing whitespace, optional sign, decimals, exponent.
// Rejects junk like "12abc".
    private static PhpNumber parseNumericStringStrict(String s) {
        if (s == null) return null;

        int n = s.length();
        int i = 0;

        while (i < n && Character.isWhitespace(s.charAt(i))) i++;
        if (i >= n) return null;

        boolean neg = false;
        char c = s.charAt(i);
        if (c == '+' || c == '-') {
            neg = (c == '-');
            i++;
            if (i >= n) return null;
        }

        boolean sawDigit = false;
        long intPart = 0;

        while (i < n) {
            char ch = s.charAt(i);
            if (ch >= '0' && ch <= '9') {
                sawDigit = true;
                int digit = ch - '0';
                if (intPart > (Long.MAX_VALUE - digit) / 10) {
                    intPart = Long.MAX_VALUE;
                } else {
                    intPart = intPart * 10 + digit;
                }
                i++;
            } else break;
        }

        boolean isFloat = false;
        double frac = 0.0;
        double base = 1.0;

        if (i < n && s.charAt(i) == '.') {
            isFloat = true;
            i++;
            while (i < n) {
                char ch = s.charAt(i);
                if (ch >= '0' && ch <= '9') {
                    sawDigit = true;
                    int digit = ch - '0';
                    base *= 10.0;
                    frac += digit / base;
                    i++;
                } else break;
            }
        }

        // exponent
        if (i < n && (s.charAt(i) == 'e' || s.charAt(i) == 'E')) {
            int j = i + 1;
            boolean expNeg = false;

            if (j < n && (s.charAt(j) == '+' || s.charAt(j) == '-')) {
                expNeg = (s.charAt(j) == '-');
                j++;
            }

            boolean sawExpDigit = false;
            int exp = 0;
            while (j < n) {
                char ch = s.charAt(j);
                if (ch >= '0' && ch <= '9') {
                    sawExpDigit = true;
                    int digit = ch - '0';
                    if (exp > (Integer.MAX_VALUE - digit) / 10) {
                        exp = Integer.MAX_VALUE;
                    } else {
                        exp = exp * 10 + digit;
                    }
                    j++;
                } else break;
            }

            if (!sawExpDigit) return null;
            isFloat = true;
            i = j;

            // apply exponent later
            double d = (double) intPart + frac;
            if (neg) d = -d;
            int signedExp = expNeg ? -exp : exp;
            d = d * Math.pow(10.0, signedExp);

            while (i < n && Character.isWhitespace(s.charAt(i))) i++;
            if (i != n) return null;

            return PhpNumber.ofDouble(d);
        }

        while (i < n && Character.isWhitespace(s.charAt(i))) i++;
        if (i != n) return null;

        if (!sawDigit) return null;

        if (isFloat) {
            double d = (double) intPart + frac;
            if (neg) d = -d;
            return PhpNumber.ofDouble(d);
        } else {
            long v = neg ? -intPart : intPart;
            return PhpNumber.ofLong(v);
        }
    }

    private static boolean isNumericStringStrict(BasePhpValue v) {
        if (v == null) return false;
        if (v.type != Type.STRING) return false;
        return parseNumericStringStrict((String) v.value) != null;
    }

    // Numeric-ish for RELATIONAL comparisons:
// - numbers
// - numeric strings
// - bool/null treated as 0/1 like usual "numeric-ish"
    private static boolean isNumericComparableForRelational(BasePhpValue v) {
        if (v == null) return true; // null
        return v.type == Type.INT
                || v.type == Type.FLOAT
                || v.type == Type.BOOL
                || v.type == Type.NULL
                || (v.type == Type.STRING && isNumericStringStrict(v));
    }

    private static PhpNumber toNumberForRelational(BasePhpValue v) {
        if (v == null || v.type == Type.NULL) return PhpNumber.ofLong(0);
        return switch (v.type) {
            case NULL -> PhpNumber.ofLong(0); // defensive (keeps the switch total)
            case BOOL -> PhpNumber.ofLong(((Boolean) v.value) ? 1 : 0);
            case INT -> PhpNumber.ofLong((Long) v.value);
            case FLOAT -> PhpNumber.ofDouble((Double) v.value);
            case STRING -> {
                PhpNumber pn = parseNumericStringStrict((String) v.value);
                // only called when numeric-string strict already checked
                yield (pn != null) ? pn : PhpNumber.ofLong(0);
            }
            case ARRAY -> throw new PhpTypeError("Cannot compare arrays");
            case OBJECT -> throw new PhpTypeError("Cannot compare objects");
        };
    }

    // Core compare for <, <=, >, >=, <=>
    // Returns -1/0/1 like spaceship.
    private static int compareForRelational(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;

        if (a.type == Type.ARRAY || b.type == Type.ARRAY) {
            throw new PhpTypeError("Cannot compare arrays");
        }
        if (a.type == Type.OBJECT || b.type == Type.OBJECT) {
            throw new PhpTypeError("Cannot compare objects");
        }

        boolean an = isNumericComparableForRelational(a);
        boolean bn = isNumericComparableForRelational(b);

        if (an && bn) {
            PhpNumber x = toNumberForRelational(a);
            PhpNumber y = toNumberForRelational(b);
            return Double.compare(x.asDouble(), y.asDouble());
        }

        String sa = a.toPhpString();
        String sb = b.toPhpString();
        int c = sa.compareTo(sb);
        return Integer.compare(c, 0);
    }

    // ---------- Operators (static for easy bytecode calls) ----------
    public static BasePhpValue add(BasePhpValue a, BasePhpValue b) {
        PhpNumber x = numForOp(a, "+", b);
        PhpNumber y = numForOp(b, "+", a);
        if (x.isDouble || y.isDouble) return of(x.asDouble() + y.asDouble());
        return of(x.asLong() + y.asLong());
    }

    public static BasePhpValue sub(BasePhpValue a, BasePhpValue b) {
        PhpNumber x = numForOp(a, "-", b);
        PhpNumber y = numForOp(b, "-", a);
        if (x.isDouble || y.isDouble) return of(x.asDouble() - y.asDouble());
        return of(x.asLong() - y.asLong());
    }

    public static BasePhpValue mul(BasePhpValue a, BasePhpValue b) {
        PhpNumber x = numForOp(a, "*", b);
        PhpNumber y = numForOp(b, "*", a);
        if (x.isDouble || y.isDouble) return of(x.asDouble() * y.asDouble());
        return of(x.asLong() * y.asLong());
    }

    public static BasePhpValue div(BasePhpValue a, BasePhpValue b) {
        PhpNumber x = numForOp(a, "/", b);
        PhpNumber y = numForOp(b, "/", a);
        double denom = y.asDouble();
        if (denom == 0.0) throw new PhpRuntimeException("Division by zero");
        return of(x.asDouble() / denom);
    }

    public static BasePhpValue mod(BasePhpValue a, BasePhpValue b) {
        PhpNumber x = numForOp(a, "%", b);
        PhpNumber y = numForOp(b, "%", a);
        long denom = y.asLong();
        if (denom == 0L) throw new PhpRuntimeException("Modulo by zero");
        return of(x.asLong() % denom);
    }

    /**
     * PHP "." concatenation.
     */
    public static BasePhpValue concat(BasePhpValue a, BasePhpValue b) {
        return of(a.toPhpString() + b.toPhpString());
    }

    /**
     * Loose equality (==) - pragmatic subset:
     * - If both numeric-ish -> compare as numbers
     * - Else compare as strings
     * - NULL equals NULL, NULL equals ""? In PHP: null == "" is true (because both convert to false/0),
     * but exact behavior is messy; we implement common coercion path.
     */
    public static BasePhpValue eq(BasePhpValue a, BasePhpValue b) {
        return of(eqBool(a, b));
    }

    public static boolean eqBool(BasePhpValue a, BasePhpValue b) {
        // arrays: compare structurally (PHP does)
        if (a.isArray() || b.isArray()) {
            if (!(a.isArray() && b.isArray())) return false;
            return a.asArray().equalsLoose(b.asArray());
        }

        // if both are number or numeric string/bool/null -> compare numbers
        boolean aNumericish = a.isNumber() || a.isNull() || a.isBool() || a.isString();
        boolean bNumericish = b.isNumber() || b.isNull() || b.isBool() || b.isString();

        if (aNumericish && bNumericish) {
            PhpNumber x = a.toNumberForArithmetic(); // uses 0 for null/bool, parses string leading number
            PhpNumber y = b.toNumberForArithmetic();
            return Double.compare(x.asDouble(), y.asDouble()) == 0;
        }

        return Objects.equals(a.toPhpString(), b.toPhpString());
    }

    /**
     * Strict identity (===): same type and same value.
     */
    public static BasePhpValue identical(BasePhpValue a, BasePhpValue b) {
        return of(identicalBool(a, b));
    }

    public static boolean identicalBool(BasePhpValue a, BasePhpValue b) {
        if (a.type != b.type) return false;
        return switch (a.type) {
            case NULL -> true;
            case BOOL, INT, FLOAT, STRING -> Objects.equals(a.value, b.value);
            case ARRAY -> a.asArray().equalsStrict(b.asArray());
            case OBJECT -> a.value == b.value;
        };
    }

    public static boolean ltBool(BasePhpValue a, BasePhpValue b) {
        return compareForRelational(a, b) < 0;
    }

    public static boolean leBool(BasePhpValue a, BasePhpValue b) {
        return compareForRelational(a, b) <= 0;
    }

    public static BasePhpValue lt(BasePhpValue a, BasePhpValue b) {
        return of(ltBool(a, b));
    }

    public static BasePhpValue le(BasePhpValue a, BasePhpValue b) {
        return of(leBool(a, b));
    }

    public static BasePhpValue gt(BasePhpValue a, BasePhpValue b) {
        return of(compareForRelational(a, b) > 0);
    }

    public static BasePhpValue ge(BasePhpValue a, BasePhpValue b) {
        return of(compareForRelational(a, b) >= 0);
    }

    // ---------- Extra operators (needed by compiler) ----------

    public static BasePhpValue spaceship(BasePhpValue a, BasePhpValue b) {
        int c = compareForRelational(a, b);
        if (c < 0) return of(-1L);
        if (c > 0) return of(1L);
        return of(0L);
    }

    /**
     * PHP logical xor (truthiness)
     */
    public static BasePhpValue xor(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        return of(a.toBool() ^ b.toBool());
    }

    /**
     * Bitwise AND (pragmatic: numeric-ish -> long)
     */
    public static BasePhpValue bitAnd(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        long y = b.toNumberForArithmetic().asLong();
        return of(x & y);
    }

    /**
     * Bitwise OR (pragmatic: numeric-ish -> long)
     */
    public static BasePhpValue bitOr(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        long y = b.toNumberForArithmetic().asLong();
        return of(x | y);
    }

    /**
     * Bitwise XOR (pragmatic: numeric-ish -> long)
     */
    public static BasePhpValue bitXor(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        long y = b.toNumberForArithmetic().asLong();
        return of(x ^ y);
    }

    /**
     * Bitwise NOT (pragmatic: numeric-ish -> long)
     */
    public static BasePhpValue bitNot(BasePhpValue a) {
        if (a == null) a = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        return of(~x);
    }

    /**
     * Left shift (<<)
     */
    public static BasePhpValue shl(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        long y = b.toNumberForArithmetic().asLong();
        int s = (int) (y & 0x3F);
        return of(x << s);
    }

    /**
     * Right shift (>>) arithmetic shift
     */
    public static BasePhpValue shr(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        long x = a.toNumberForArithmetic().asLong();
        long y = b.toNumberForArithmetic().asLong();
        int s = (int) (y & 0x3F);
        return of(x >> s);
    }

    /**
     * Power (**) - pragmatic: use double math
     */
    public static BasePhpValue pow(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        PhpNumber x = a.toNumberForArithmetic();
        PhpNumber y = b.toNumberForArithmetic();
        return of(Math.pow(x.asDouble(), y.asDouble()));
    }

    /**
     * instanceof (pragmatic: only exact class name match for now)
     */
    public static BasePhpValue instanceOf(BasePhpValue left, BasePhpValue right) {
        if (left == null) left = NULL_VALUE;
        if (right == null) right = NULL_VALUE;

        if (!left.isObject()) return of(false);

        String want = right.toPhpString();
        if (want == null) want = "";
        want = want.toLowerCase();

        PhpObject obj = left.asObject();
        PhpClass c = obj.getPhpClass();
        while (c != null) {
            if (c.getName().equalsIgnoreCase(want)) return of(true);
            c = c.getParent();
        }
        return of(false);
    }

    // ---------- Array operations ----------

    /**
     * $arr[$key]
     * If key missing: returns NULL_VALUE (PHP would also raise a notice/warning in many cases).
     */
    public static BasePhpValue arrayGet(BasePhpValue arr, BasePhpValue key) {
        if (!arr.isArray()) throw new PhpRuntimeException("Cannot index non-array type: " + arr.type);
        PhpKey k = PhpKey.fromValue(key);
        BasePhpValue v = arr.asArray().get(k);
        return v == null ? NULL_VALUE : v;
    }

    /**
     * $arr[$key] = $value
     */
    public static void arraySet(BasePhpValue arr, BasePhpValue key, BasePhpValue value) {
        if (!arr.isArray()) throw new PhpRuntimeException("Cannot index-assign non-array type: " + arr.type);
        PhpKey k = PhpKey.fromValue(key);
        arr.asArray().put(k, value == null ? NULL_VALUE : value);
    }

    /**
     * $arr[] = $value  (append)
     */
    public static void arrayAppend(BasePhpValue arr, BasePhpValue value) {
        if (!arr.isArray()) throw new PhpRuntimeException("Cannot append to non-array type: " + arr.type);
        arr.asArray().append(value == null ? NULL_VALUE : value);
    }

    // ---------- Extra operators for bytecode-friendly codegen ----------

    public static BasePhpValue not(BasePhpValue a) {
        if (a == null) a = NULL_VALUE;
        return of(!a.toBool());
    }

    public static BasePhpValue and(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        return of(a.toBool() && b.toBool());
    }

    public static BasePhpValue or(BasePhpValue a, BasePhpValue b) {
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;
        return of(a.toBool() || b.toBool());
    }

    public static BasePhpValue ne(BasePhpValue a, BasePhpValue b) {
        return of(!eqBool(a, b));
    }

    public static BasePhpValue notIdentical(BasePhpValue a, BasePhpValue b) {
        return of(!identicalBool(a, b));
    }

    // ---------- PHP builtins (bytecode-friendly) ----------

    public static BasePhpValue count(BasePhpValue v) {
        v = deref(v);
        if (v == null || v.isNull()) return of(0L);
        if (v.isArray()) return of((long) v.asArray().map.size());

        // pragmatic: non-array, non-null => 1 (older PHP behavior)
        // (PHP 8 throws TypeError for non-countable, but this keeps your runtime forgiving)
        return of(1L);
    }

    public static BasePhpValue trim(BasePhpValue v) {
        v = deref(v);
        if (v == null || v.isNull()) return of("");

        String s = v.toPhpString();
        if (s == null) s = "";
        // Java 11+: strips Unicode whitespace similarly to PHP's default whitespace trim (good enough)
        return of(s.strip());
    }

    // Supports:
    // - implode($glue, $pieces)
    // - implode($pieces)   (compiler can pass second arg NULL)
    // - swapped historical form: implode($pieces, $glue) (we detect and swap if first is array)
    public static BasePhpValue implode(BasePhpValue a, BasePhpValue b) {
        a = deref(a);
        b = deref(b);
        if (a == null) a = NULL_VALUE;
        if (b == null) b = NULL_VALUE;

        // one-arg form
        if (b.isNull()) {
            return implodeInternal(of(""), a);
        }

        // swapped form: first is array, second is glue
        if (a.isArray() && !b.isArray()) {
            return implodeInternal(b, a);
        }

        return implodeInternal(a, b);
    }

    private static BasePhpValue implodeInternal(BasePhpValue glue, BasePhpValue pieces) {
        glue = deref(glue);
        pieces = deref(pieces);
        if (glue == null) glue = NULL_VALUE;
        if (pieces == null) pieces = NULL_VALUE;

        String sep = glue.isNull() ? "" : glue.toPhpString();
        if (sep == null) sep = "";

        if (pieces.isNull()) return of("");

        if (!pieces.isArray()) {
            // pragmatic fallback
            return of(pieces.toPhpString());
        }

        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (Map.Entry<PhpKey, BasePhpValue> e : pieces.asArray().map.entrySet()) {
            if (!first) sb.append(sep);
            first = false;

            BasePhpValue pv = deref(e.getValue());
            if (pv == null) pv = NULL_VALUE;
            sb.append(pv.toPhpString());
        }
        return of(sb.toString());
    }

    // ---------- Debug / printing ----------
    @Override
    public String toString() {
        return switch (type) {
            case NULL -> "NULL";
            case BOOL -> "BOOL(" + value + ")";
            case INT -> "INT(" + value + ")";
            case FLOAT -> "FLOAT(" + value + ")";
            case STRING -> "STRING(\"" + value + "\")";
            case ARRAY -> "ARRAY(" + asArray().debugString() + ")";
            case OBJECT -> "OBJECT(" + asObject().getPhpClass().getName() + ")";
        };
    }

    // ---------- Helper: numeric wrapper ----------
    private static final class PhpNumber {
        final boolean isDouble;
        final long asLong;
        final double asDouble;

        private PhpNumber(boolean isDouble, long asLong, double asDouble) {
            this.isDouble = isDouble;
            this.asLong = asLong;
            this.asDouble = asDouble;
        }

        static PhpNumber ofLong(long v) {
            return new PhpNumber(false, v, (double) v);
        }

        static PhpNumber ofDouble(double v) {
            // when we carry a double, also keep a long cast for % and such
            return new PhpNumber(true, (long) v, v);
        }

        long asLong() {
            return asLong;
        }

        double asDouble() {
            return asDouble;
        }
    }

    // ---------- Helper: PHP array key ----------

    /**
     * PHP array keys are either int or string.
     * Booleans and floats cast to int; null casts to "" in some contexts; we keep it simple.
     */
    public static final class PhpKey {
        private enum K {INT, STRING}

        private final K kind;
        private final long intKey;
        private final String strKey;

        private PhpKey(long i) {
            this.kind = K.INT;
            this.intKey = i;
            this.strKey = null;
        }

        private PhpKey(String s) {
            this.kind = K.STRING;
            this.intKey = 0L;
            this.strKey = (s == null) ? "" : s;
        }

        public static PhpKey of(long i) {
            return new PhpKey(i);
        }

        public static PhpKey of(String s) {
            return new PhpKey(s);
        }

        public static PhpKey fromValue(BasePhpValue v) {
            if (v == null || v.isNull()) return of("");
            return switch (v.type) {
                case INT -> of((Long) v.value);
                case FLOAT -> of((long) ((Double) v.value).doubleValue());
                case BOOL -> of(((Boolean) v.value) ? 1L : 0L);
                case STRING -> {
                    String s = (String) v.value;
                    PhpKey maybe = tryParseIntStringKey(s);
                    yield maybe != null ? maybe : of(s);
                }
                case ARRAY -> throw new PhpRuntimeException("Illegal array key type: array");
                case OBJECT -> throw new PhpRuntimeException("Illegal array key type: object");
                case NULL -> of("");
            };
        }

        private static PhpKey tryParseIntStringKey(String s) {
            if (s == null || s.isEmpty()) return null;
            int i = 0;
            int n = s.length();
            boolean neg = false;

            if (s.charAt(0) == '+' || s.charAt(0) == '-') {
                neg = (s.charAt(0) == '-');
                i++;
                if (i >= n) return null;
            }

            long val = 0;
            boolean saw = false;
            for (; i < n; i++) {
                char ch = s.charAt(i);
                if (ch < '0' || ch > '9') return null;
                saw = true;
                int digit = ch - '0';
                if (val > (Long.MAX_VALUE - digit) / 10) {
                    val = Long.MAX_VALUE;
                } else {
                    val = val * 10 + digit;
                }
            }
            if (!saw) return null;
            return of(neg ? -val : val);
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof PhpKey other)) return false;
            if (this.kind != other.kind) return false;
            return (kind == K.INT) ? (this.intKey == other.intKey) : this.strKey.equals(other.strKey);
        }

        @Override
        public int hashCode() {
            return (kind == K.INT) ? Long.hashCode(intKey) * 31 + 1 : Objects.hash(strKey) * 31 + 2;
        }

        @Override
        public String toString() {
            return (kind == K.INT) ? String.valueOf(intKey) : "\"" + strKey + "\"";
        }
    }

    // ---------- Helper: PHP array value ----------
    public static final class PhpArray {
        private final LinkedHashMap<PhpKey, BasePhpValue> map = new LinkedHashMap<>();
        private long nextAutoIndex = 0;

        public boolean isEmpty() {
            return map.isEmpty();
        }

        public BasePhpValue get(PhpKey k) {
            return map.get(k);
        }

        public void put(PhpKey k, BasePhpValue v) {
            if (k == null) throw new PhpRuntimeException("Null array key");
            if (v == null) v = NULL_VALUE;

            map.put(k, v);

            // PHP: if you set a numeric key >= nextAutoIndex, bump auto index
            // only for int keys
            // (good enough for $arr[] behavior)
            if (isIntKey(k)) {
                long ik = getIntKey(k);
                if (ik >= nextAutoIndex) nextAutoIndex = ik + 1;
            }
        }

        public void append(BasePhpValue v) {
            if (v == null) v = NULL_VALUE;
            PhpKey k = PhpKey.of(nextAutoIndex);
            map.put(k, v);
            nextAutoIndex++;
        }

        private static boolean isIntKey(PhpKey k) {
            // hacky but safe due to toString? Better: reflect kind by behavior:
            // We'll detect by hash behavior? No. We'll use equals with an int-made key:
            // If it's an int key, it equals another int key with same number, not string.
            // We can do a more direct approach by inspecting its toString is risky.
            // So we keep this tiny reflection-free trick:
            // if it equals itself when rebuilt from toString numeric? Not safe.
            // We'll instead store kind indirectly: PhpKey has kind private, but same top-level class can access it.
            return k.kind == PhpKey.K.INT;
        }

        private static long getIntKey(PhpKey k) {
            return k.intKey;
        }

        public boolean equalsLoose(PhpArray other) {
            if (other == null) return false;
            if (this.map.size() != other.map.size()) return false;
            for (Map.Entry<PhpKey, BasePhpValue> e : this.map.entrySet()) {
                BasePhpValue ov = other.map.get(e.getKey());
                if (ov == null) return false;
                if (!BasePhpValue.eqBool(e.getValue(), ov)) return false;
            }
            return true;
        }

        public boolean equalsStrict(PhpArray other) {
            if (other == null) return false;
            if (this.map.size() != other.map.size()) return false;
            for (Map.Entry<PhpKey, BasePhpValue> e : this.map.entrySet()) {
                BasePhpValue ov = other.map.get(e.getKey());
                if (ov == null) return false;
                if (!BasePhpValue.identicalBool(e.getValue(), ov)) return false;
            }
            return true;
        }

        public String debugString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{");
            boolean first = true;
            for (Map.Entry<PhpKey, BasePhpValue> e : map.entrySet()) {
                if (!first) sb.append(", ");
                first = false;
                sb.append(e.getKey()).append(": ").append(e.getValue());
            }
            sb.append("}");
            return sb.toString();
        }
    }

    private static boolean matchesDeclaredType(BasePhpValue v, String t) {
        v = deref(v);
        if (v == null) v = NULL_VALUE;
        if (t == null) t = "";
        t = t.trim().toLowerCase();

        if (t.isEmpty() || t.equals("mixed")) return true;

        boolean nullable = false;
        if (t.startsWith("?")) {
            nullable = true;
            t = t.substring(1);
        }

        if (nullable && v.type == Type.NULL) return true;
        if (t.equals("null")) return v.type == Type.NULL;

        return switch (t) {
            case "int", "integer" -> v.type == Type.INT;
            case "float", "double" -> v.type == Type.FLOAT;
            case "string" -> v.type == Type.STRING;
            case "bool", "boolean" -> v.type == Type.BOOL;
            case "array" -> v.type == Type.ARRAY;
            case "object" -> v.type == Type.OBJECT;
            default -> true; // unknown types treated as permissive for now
        };
    }

    private static boolean matchesUnion(BasePhpValue v, String union) {
        if (union == null) union = "";
        union = union.trim();
        if (union.isEmpty() || union.equalsIgnoreCase("mixed")) return true;

        String[] parts = union.split("\\|");
        for (String p : parts) {
            if (matchesDeclaredType(v, p)) return true;
        }
        return false;
    }

    public static BasePhpValue assertParamType(BasePhpValue v, String fn, int index, String paramName, String expectedUnion) {
        v = (v == null) ? NULL_VALUE : v;
        if (matchesUnion(v, expectedUnion)) return v;

        String n = (fn == null || fn.isEmpty()) ? "<function>" : fn;
        String p = (paramName == null || paramName.isEmpty()) ? "" : " ($" + paramName + ")";
        String got = phpTypeNameOf(v);
        throw new PhpTypeError(n + "(): Argument " + index + p + " must be of type " + expectedUnion + ", " + got + " given");
    }

    public static BasePhpValue assertReturnType(BasePhpValue v, String fn, String expectedUnion) {
        v = (v == null) ? NULL_VALUE : v;
        if (matchesUnion(v, expectedUnion)) return v;

        String n = (fn == null || fn.isEmpty()) ? "<function>" : fn;
        String got = phpTypeNameOf(v);
        throw new PhpTypeError(n + "(): Return value must be of type " + expectedUnion + ", " + got + " returned");
    }

    public static String phpTypeNameOf(BasePhpValue v) {
        v = deref(v);
        if (v == null) return "null";
        return phpTypeName(v);
    }

    // ---------- Runtime type error ----------
    public static final class PhpTypeError extends RuntimeException {
        public PhpTypeError(String message) {
            super(message);
        }
    }

    private static String phpTypeName(BasePhpValue v) {
        if (v == null) return "null";
        return switch (v.type) {
            case NULL -> "null";
            case BOOL -> "bool";
            case INT -> "int";
            case FLOAT -> "float";
            case STRING -> "string";
            case ARRAY -> "array";
            case OBJECT -> "object";
        };
    }

    private static PhpTypeError unsupportedOperandTypes(String op, BasePhpValue a, BasePhpValue b) {
        return new PhpTypeError("Unsupported operand types: " + phpTypeName(a) + " " + op + " " + phpTypeName(b));
    }

    // ---------- Runtime error ----------
    public static final class PhpRuntimeException extends RuntimeException {
        public PhpRuntimeException(String message) {
            super(message);
        }

        public PhpRuntimeException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
